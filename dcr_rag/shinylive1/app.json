[{"name": "app.py", "content": "from all_rag_fns import do_rag\nfrom shiny import reactive\nfrom shiny.express import input, render, ui\n\n# Enhanced CSS with animations and better styling\nui.tags.style(\n    \"\"\"\n    :root {\n        --primary-color: #2c3e50;\n        --secondary-color: #34495e;\n        --accent-color: #3498db;\n        --bg-light: #f8f9fa;\n        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n        --transition: all 0.3s ease;\n    }\n\n    body {\n        background-color: #f5f6fa;\n    }\n\n    .main-title {\n        color: var(--primary-color);\n        margin-bottom: 30px;\n        font-weight: 600;\n        border-bottom: 3px solid var(--accent-color);\n        padding-bottom: 10px;\n        transition: var(--transition);\n    }\n\n    .main-title:hover {\n        color: var(--accent-color);\n    }\n\n    .card {\n        border: none !important;\n        box-shadow: var(--shadow) !important;\n        transition: var(--transition) !important;\n        margin-bottom: 25px !important;\n        border-radius: 12px !important;\n        overflow: hidden;\n    }\n\n    .card:hover {\n        transform: translateY(-5px);\n        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15) !important;\n    }\n\n    .card-header {\n        background-color: var(--primary-color) !important;\n        color: white !important;\n        font-weight: 500;\n        padding: 15px 20px !important;\n        border-bottom: none !important;\n    }\n\n    .contact-section {\n        background: linear-gradient(145deg, var(--bg-light), #ffffff);\n        padding: 25px;\n        border-radius: 15px;\n        margin-top: 30px;\n        box-shadow: var(--shadow);\n        transition: var(--transition);\n    }\n\n    .contact-section:hover {\n        transform: translateY(-3px);\n        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);\n    }\n\n    .contact-section img {\n        border-radius: 50%;\n        margin-right: 20px;\n        vertical-align: middle;\n        border: 3px solid var(--accent-color);\n        transition: var(--transition);\n    }\n\n    .contact-section img:hover {\n        transform: scale(1.1);\n    }\n\n    .contact-links {\n        display: inline-block;\n        vertical-align: middle;\n    }\n\n    .contact-links a {\n        color: var(--accent-color);\n        text-decoration: none;\n        margin: 0 10px;\n        transition: var(--transition);\n    }\n\n    .contact-links a:hover {\n        color: var(--primary-color);\n        text-decoration: underline;\n    }\n\n    .btn-primary {\n        background-color: var(--accent-color) !important;\n        border: none !important;\n        padding: 10px 25px !important;\n        transition: var(--transition) !important;\n    }\n\n    .btn-primary:hover {\n        background-color: var(--primary-color) !important;\n        transform: translateY(-2px);\n        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);\n    }\n\n    .video-container {\n        display: flex;\n        flex-wrap: wrap;\n        gap: 25px;\n        justify-content: space-around;\n        padding: 20px;\n    }\n\n    .video-item {\n        width: 30%;\n        min-width: 300px;\n        background: #ffffff;\n        border-radius: 12px;\n        padding: 20px;\n        box-shadow: var(--shadow);\n        transition: var(--transition);\n    }\n\n    .video-item:hover {\n        transform: translateY(-5px);\n        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);\n    }\n\n    .video-item h3 {\n        color: var(--primary-color);\n        margin-bottom: 15px;\n        font-weight: 600;\n    }\n\n    .video-item p {\n        color: var(--secondary-color);\n        margin: 8px 0;\n        line-height: 1.6;\n    }\n\n    .video-item iframe {\n        border-radius: 10px;\n        margin: 15px 0;\n        width: 100%;\n        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    }\n\n    .video-item details {\n        margin-top: 15px;\n        border-top: 1px solid #eee;\n        padding-top: 15px;\n    }\n\n    .video-item details summary {\n        cursor: pointer;\n        color: var(--accent-color);\n        font-weight: 500;\n        transition: var(--transition);\n    }\n\n    .video-item details summary:hover {\n        color: var(--primary-color);\n    }\n\n    /* Responsive adjustments */\n    @media (max-width: 1200px) {\n        .video-item {\n            width: 45%;\n        }\n    }\n\n    @media (max-width: 768px) {\n        .video-item {\n            width: 100%;\n        }\n        .contact-section {\n            text-align: center;\n        }\n        .contact-section img {\n            margin-bottom: 15px;\n        }\n    }\n\n    /* Input styling */\n    .form-control {\n        border-radius: 8px !important;\n        border: 1px solid #dee2e6 !important;\n        padding: 12px !important;\n        transition: var(--transition) !important;\n    }\n\n    .form-control:focus {\n        border-color: var(--accent-color) !important;\n        box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25) !important;\n    }\n\"\"\"\n)\n\nui.page_opts(\n    title=\"Use Shiny to Run RAG on the previous R/Gov Talks\",\n    # fillable=True,\n    # fillable_mobile=True,\n)\n\nui.h2(\"RAG on R/Gov Talks\", class_=\"main-title\")\n\nwith ui.layout_sidebar():\n    with ui.sidebar():\n        ui.div(\n            {\"style\": \"padding: 20px;\"},\n            ui.h3(\"Settings\", style=\"color: #2c3e50; margin-bottom: 20px;\"),\n            ui.input_password(\n                \"api_key\",\n                \"OpenAI API Key:\",\n                placeholder=\"Enter your API key\",\n                width=\"100%\",\n            ),\n            ui.hr(),\n            ui.input_radio_buttons(\n                \"model_choice\",\n                \"Select Model:\",\n                choices={\"gpt-4o-mini\": \"Cheaper\", \"gpt-4o\": \"More Accurate\"},\n                selected=\"gpt-4o-mini\",\n            ),\n            ui.hr(),\n            # About section moved to sidebar\n            ui.h3(\n                \"About\", style=\"color: #2c3e50; margin-top: 20px; margin-bottom: 10px;\"\n            ),\n            ui.markdown(\n                \"\"\"\n                This app was created for Alan Feder's [talk at the 2024 R/Gov Conference](https://rstats.ai/gov.html).\n\n                The Github repository that houses all the code is [here](https://github.com/AlanFeder/rgov-2024) -- feel free to fork it and use it on your own!\n                \"\"\"\n            ),\n            ui.hr(),\n            # Contact section moved to sidebar\n            ui.h3(\n                \"Contact me!\",\n                style=\"color: #2c3e50; margin-top: 20px; margin-bottom: 10px;\",\n            ),\n            ui.div(\n                {\"class\": \"contact-section\", \"style\": \"padding: 10px 0;\"},\n                ui.img(\n                    src=\"https://raw.githubusercontent.com/AlanFeder/rgov-2024/refs/heads/main/AJF_Headshot.jpg\",\n                    width=\"60px\",\n                ),\n                ui.div(\n                    {\"class\": \"contact-links\"},\n                    ui.markdown(\n                        \"\"\"\n                        [Email](mailto:AlanFeder@gmail.com) | [Website](https://www.alanfeder.com/) | [LinkedIn](https://www.linkedin.com/in/alanfeder/) | [GitHub](https://github.com/AlanFeder)\n                        \"\"\"\n                    ),\n                ),\n            ),\n        )\n\n    with ui.card(class_=\"query-card\"):\n        ui.card_header(\"Ask a Question\")\n        ui.input_text(\n            id=\"query1\",\n            label=\"What question do you want to ask?\",\n            placeholder=\"What is the tidyverse?\",\n            width=\"100%\",\n        )\n        ui.div(\n            {\"style\": \"padding: 15px 0;\"},\n            ui.input_action_button(\n                \"run_rag\", \"Submit!\", class_=\"btn-primary\", width=\"200px\"\n            ),\n        )\n\n    with ui.card(class_=\"response-card\"):\n        ui.card_header(\"AI Response\")\n\n        @render.ui\n        def render_response():\n            ans = rag_answer()\n            return ui.markdown(ans)\n\n    with ui.card():\n        ui.card_header(\"Related Videos\")\n\n        @render.ui\n        def create_video_html():\n            video_info = list_retrieved_docs()\n            html = '<div class=\"video-container\">'\n\n            for vid_info in video_info:\n                yt_id = vid_info[\"VideoURL\"].split(\"/\")[-1].split(\"=\")[-1]\n                yt_url = f\"https://www.youtube.com/embed/{yt_id}\"\n                html += f\"\"\"\n                <div class=\"video-item\">\n                    <h3>{vid_info[\"Title\"]}</h3>\n                    <p><em>{vid_info[\"Speaker\"]}</em></p>\n                    <p>Year: {vid_info[\"Year\"]}</p>\n                    <p>Similarity Score: {100 * vid_info[\"score\"]:.0f}/100</p>\n                    <iframe height=\"215\" src=\"{yt_url}\" frameborder=\"0\" allowfullscreen></iframe>\n                    <details>\n                        <summary>Transcript</summary>\n                        <p>{vid_info[\"transcript\"]}</p>\n                    </details>\n                </div>\n                \"\"\"\n            html += \"</div>\"\n            return ui.HTML(html)\n\n\nrag_answer = reactive.value(\"\")\nlist_retrieved_docs = reactive.value([])\n\n\n@reactive.effect\n@reactive.event(input.run_rag)\ndef do_rag_shiny():\n    oai_api_key = input.api_key()\n    response, retrieved_docs = do_rag(\n        user_input=input.query1(),\n        n_results=3,\n        stream=False,\n        oai_api_key=oai_api_key,\n        model_name=input.model_choice(),\n    )\n\n    rag_answer.set(response)\n    list_retrieved_docs.set(retrieved_docs)\n", "type": "text"}, {"name": "all_rag_fns.py", "content": "import io\nimport json\n\nimport numpy as np\nimport requests\n\n\ndef import_talk_info() -> list[dict]:\n    \"\"\"\n    Import talk info from file.\n\n    Returns:\n        list[dict]: A list of talk info.\n    \"\"\"\n\n    target_file_url = \"https://raw.githubusercontent.com/AlanFeder/rgov-2024/main/data/rgov_talks.json\"\n\n    response = requests.get(target_file_url)\n    response.raise_for_status()  # Ensure we notice if the download fails\n    return response.json()\n\n\ndef import_embeds() -> np.ndarray:\n    \"\"\"\n    Import embeddings from file.\n\n    Returns:\n        np.ndarray: The embeddings.\n    \"\"\"\n\n    target_file_url = (\n        \"https://raw.githubusercontent.com/AlanFeder/rgov-2024/main/data/embeds.csv\"\n    )\n\n    response = requests.get(target_file_url)\n    response.raise_for_status()\n\n    # Use numpy.genfromtxt to read the CSV data from the response text\n    data = np.genfromtxt(\n        io.StringIO(response.text), delimiter=\",\"\n    )  # skip header if needed\n\n    return data\n\n\ndef import_data() -> tuple[list[dict], np.ndarray]:\n    #     \"\"\"\n    #     Import data from files.\n\n    #     Returns:\n    #         tuple[list[dict], dict]: A tuple containing the talk info and embeddings.\n    #     \"\"\"\n\n    talk_info = import_talk_info()\n    embeds = import_embeds()\n\n    return talk_info, embeds\n\n\ndef do_1_embed(lt: str, oai_api_key: str) -> np.ndarray:\n    \"\"\"\n    Generate embeddings using the OpenAI API for a single text.\n\n    Args:\n        lt (str): A text to generate embeddings for.\n        emb_client (OpenAI): The embedding API client (OpenAI).\n\n    Returns:\n        np.ndarray: The generated embeddings.\n    \"\"\"\n    # OpenAI API endpoint for embeddings\n    url = \"https://api.openai.com/v1/embeddings\"\n\n    # Headers for the API request\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {oai_api_key}\",\n    }\n\n    # Request payload\n    payload = {\"input\": lt, \"model\": \"text-embedding-3-small\"}\n\n    # Make the API request\n    response = requests.post(url, headers=headers, data=json.dumps(payload))\n\n    # Check if the request was successful\n    if response.status_code == 200:\n        # Parse the JSON response\n        embed_response = response.json()\n\n        # Extract the embedding\n        here_embed = np.array(embed_response[\"data\"][0][\"embedding\"])\n\n        return here_embed\n    else:\n        print(f\"Error: {response.status_code}\")\n        print(response.text)\n\n\ndef do_sort(\n    embed_q: np.ndarray, embed_talks: np.ndarray, list_talk_ids: list[str]\n) -> list[dict[str, str | float]]:\n    \"\"\"\n    Sort documents based on their cosine similarity to the query embedding.\n\n    Args:\n        embed_dict (dict[str, np.ndarray]): Dictionary containing document embeddings.\n        arr_q (np.ndarray): Query embedding.\n\n    Returns:\n        pd.DataFrame: Sorted dataframe containing document IDs and similarity scores.\n    \"\"\"\n\n    # Calculate cosine similarities between query embedding and document embeddings\n    cos_sims = np.dot(embed_talks, embed_q)\n\n    # Get the indices of the best matching video IDs\n    best_match_video_ids = np.argsort(-cos_sims)\n\n    # Get the sorted video IDs based on the best match indices\n    sorted_vids = [\n        {\"id0\": list_talk_ids[i], \"score\": -cs}\n        for i, cs in zip(best_match_video_ids, np.sort(-cos_sims))\n    ]\n\n    return sorted_vids\n\n\ndef limit_docs(\n    sorted_vids: list[dict],\n    talk_info: dict,\n    n_results: int,\n) -> list[dict]:\n    \"\"\"\n    Limit the retrieved documents based on a score threshold and return the top documents.\n\n    Args:\n        df_sorted (pd.DataFrame): Sorted dataframe containing document IDs and similarity scores.\n        df_talks (pd.DataFrame): Dataframe containing talk information.\n        n_results (int): Number of top documents to retrieve.\n        transcript_dicts (dict[str, dict]): Dictionary containing transcript text for each document ID.\n\n    Returns:\n        dict[str, dict]: Dictionary containing the top documents with their IDs, scores, and text.\n    \"\"\"\n\n    # Get the top n_results documents\n    top_vids = sorted_vids[:n_results]\n\n    # Get the top score and calculate the score threshold\n    top_score = top_vids[0][\"score\"]\n    score_thresh = max(min(0.6, top_score - 0.2), 0.2)\n\n    # Filter the top documents based on the score threshold\n    keep_texts = []\n    for my_vid in top_vids:\n        if my_vid[\"score\"] >= score_thresh:\n            vid_data = talk_info[my_vid[\"id0\"]]\n            vid_data = {**vid_data, **my_vid}\n            keep_texts.append(vid_data)\n\n    return keep_texts\n\n\ndef do_retrieval(\n    query0: str,\n    n_results: int,\n    oai_api_key: str,\n    embeds: np.ndarray,\n    talk_info: dict[str, str | int],\n) -> list[dict]:\n    \"\"\"\n    Retrieve relevant documents based on the user's query.\n\n    Args:\n        query0 (str): The user's query.\n        n_results (int): The number of documents to retrieve.\n        api_client (OpenAI): The API client (OpenAI) for generating embeddings.\n\n    Returns:\n        dict[str, dict]: The retrieved documents.\n    \"\"\"\n    try:\n        # Generate embeddings for the query\n        arr_q = do_1_embed(query0, oai_api_key=oai_api_key)\n\n        # reformat to be like old version\n        talk_ids = [ti[\"id0\"] for ti in talk_info]\n        talk_info = {ti[\"id0\"]: ti for ti in talk_info}\n\n        # Sort documents based on their cosine similarity to the query embedding\n        sorted_vids = do_sort(embed_q=arr_q, embed_talks=embeds, list_talk_ids=talk_ids)\n\n        # Limit the retrieved documents based on a score threshold\n        keep_texts = limit_docs(\n            sorted_vids=sorted_vids, talk_info=talk_info, n_results=n_results\n        )\n\n        return keep_texts\n    except Exception as e:\n        raise e\n\n\nSYSTEM_PROMPT = \"\"\"\nYou are an AI assistant that helps answer questions by searching through video transcripts. \nI have retrieved the transcripts most likely to answer the user's question.\nCarefully read through the transcripts to find information that helps answer the question. \nBe brief - your response should not be more than two paragraphs.\nOnly use information directly stated in the provided transcripts to answer the question. \nDo not add any information or make any claims that are not explicitly supported by the transcripts.\nIf the transcripts do not contain enough information to answer the question, state that you do not have enough information to provide a complete answer.\nFormat the response clearly.  If only one of the transcripts answers the question, don't reference the other and don't explain why its content is irrelevant.\nDo not speak in the first person. DO NOT write a letter, make an introduction, or salutation.\nReference the speaker's name when you say what they said.\n\"\"\"\n\n\ndef set_messages(system_prompt: str, user_prompt: str) -> list[dict[str, str]]:\n    \"\"\"\n    Set the messages for the chat completion.\n\n    Args:\n        system_prompt (str): The system prompt.\n        user_prompt (str): The user prompt.\n\n    Returns:\n        tuple[list[dict[str, str]], int]: A tuple containing the messages and the total number of input tokens.\n    \"\"\"\n    messages1 = [\n        {\"role\": \"system\", \"content\": system_prompt},\n        {\"role\": \"user\", \"content\": user_prompt},\n    ]\n\n    return messages1\n\n\ndef make_user_prompt(question: str, keep_texts: list[dict]) -> str:\n    \"\"\"\n    Create the user prompt based on the question and the retrieved transcripts.\n\n    Args:\n        question (str): The user's question.\n        keep_texts (dict[str, dict[str, str]]): The retrieved transcripts.\n\n    Returns:\n        str: The user prompt.\n    \"\"\"\n    user_prompt = f\"\"\"\nQuestion: {question}\n==============================\n\"\"\"\n    if len(keep_texts) > 0:\n        list_strs = []\n        for i, tx_val in enumerate(keep_texts):\n            text0 = tx_val[\"transcript\"]\n            speaker_name = tx_val[\"Speaker\"]\n            list_strs.append(\n                f\"Video Transcript {i+1}\\nSpeaker: {speaker_name}\\n{text0}\"\n            )\n        user_prompt += \"\\n-------\\n\".join(list_strs)\n        user_prompt += \"\"\"\n==============================\nAfter analyzing the above video transcripts, please provide a helpful answer to my question. Remember to stay within two paragraphs\nAddress the response to me directly.  Do not use any information not explicitly supported by the transcripts. Remember to reference the speaker's name.\"\"\"\n    else:\n        # If no relevant transcripts are found, generate a default response\n        user_prompt += \"No relevant video transcripts were found.  Please just return a result that says something like 'I'm sorry, but the answer to {Question} was not found in the transcripts from the R/Gov Conference'\"\n    # logger.info(f'User prompt: {user_prompt}')\n    return user_prompt\n\n\ndef parse_1_query_stream(response):\n    # Check if the request was successful\n    if response.status_code == 200:\n        for line in response.iter_lines():\n            if line:\n                line = line.decode(\"utf-8\")\n                if line.startswith(\"data: \"):\n                    data = line[6:]  # Remove 'data: ' prefix\n                    if data != \"[DONE]\":\n                        try:\n                            chunk = json.loads(data)\n                            content = chunk[\"choices\"][0][\"delta\"].get(\"content\", \"\")\n                            if content:\n                                yield content\n                        except json.JSONDecodeError:\n                            yield f\"Error decoding JSON: {data}\"\n    else:\n        yield f\"Error: {response.status_code}\\n{response.text}\"\n\n\ndef parse_1_query_no_stream(response):\n    if response.status_code == 200:\n        try:\n            response1 = response.json()\n            completion = response1[\"choices\"][0][\"message\"][\"content\"]\n            return completion\n        except json.JSONDecodeError:\n            return f\"Error decoding JSON: {response.text}\"\n    else:\n        return f\"Error: {response.status_code}\\n{response.text}\"\n\n\ndef do_1_query(\n    messages1: list[dict[str, str]], oai_api_key: str, stream: bool, model_name: str\n):\n    \"\"\"\n    Generate a response using the specified chat completion model.\n\n    Args:\n        messages1 (list[dict[str, str]]): The messages for the chat completion.\n        gen_client (OpenAI): The generation client (OpenAI).\n    \"\"\"\n\n    # OpenAI API endpoint for chat completions\n    url = \"https://api.openai.com/v1/chat/completions\"\n\n    # Your OpenAI API key\n    # Headers for the API request\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {oai_api_key}\",\n    }\n    if stream:\n        headers[\"Accept\"] = \"text/event-stream\"  # Required for streaming\n\n    # Model to use\n    model1 = model_name\n\n    # Request payload\n    payload = {\n        \"model\": model1,\n        \"messages\": messages1,\n        \"seed\": 18,\n        \"temperature\": 0,\n        \"stream\": stream,\n    }\n\n    # Make the API request\n    response = requests.post(\n        url, headers=headers, data=json.dumps(payload), stream=stream\n    )\n\n    if stream:\n        response1 = parse_1_query_stream(response)\n    else:\n        # Check if the request was successful\n        response1 = parse_1_query_no_stream(response)\n\n    return response1\n\n\ndef do_generation(\n    query1: str, keep_texts: list[dict], oai_api_key: str, stream: bool, model_name: str\n):\n    \"\"\"\n    Generate the chatbot response using the specified generation client.\n\n    Args:\n        query1 (str): The user's query.\n        keep_texts (dict[str, dict[str, str]]): The retrieved relevant texts.\n        gen_client (OpenAI): The generation client (OpenAI).\n\n    Returns:\n        tuple[Stream, int]: A tuple containing the generated response stream and the number of prompt tokens.\n    \"\"\"\n    user_prompt = make_user_prompt(query1, keep_texts=keep_texts)\n    messages1 = set_messages(SYSTEM_PROMPT, user_prompt)\n    response = do_1_query(\n        messages1, oai_api_key=oai_api_key, stream=stream, model_name=model_name\n    )\n\n    return response\n\n\ndef calc_cost(\n    prompt_tokens: int, completion_tokens: int, embedding_tokens: int\n) -> float:\n    \"\"\"\n    Calculate the cost in cents based on the number of prompt, completion, and embedding tokens.\n\n    Args:\n        prompt_tokens (int): The number of tokens in the prompt.\n        completion_tokens (int): The number of tokens in the completion.\n        embedding_tokens (int): The number of tokens in the embedding.\n\n    Returns:\n        float: The cost in cents.\n    \"\"\"\n    prompt_cost = prompt_tokens / 2000\n    completion_cost = 3 * completion_tokens / 2000\n    embedding_cost = embedding_tokens / 500000\n\n    cost_cents = prompt_cost + completion_cost + embedding_cost\n\n    return cost_cents\n\n\ndef do_rag(\n    user_input: str,\n    oai_api_key: str,\n    model_name: str,\n    stream: bool = False,\n    n_results: int = 3,\n):\n    # Load the data\n    talk_info, embeds = import_data()\n    # Load the model\n\n    retrieved_docs = do_retrieval(\n        query0=user_input,\n        n_results=n_results,\n        oai_api_key=oai_api_key,\n        embeds=embeds,\n        talk_info=talk_info,\n    )\n\n    response = do_generation(\n        query1=user_input,\n        keep_texts=retrieved_docs,\n        model_name=model_name,\n        oai_api_key=oai_api_key,\n        stream=stream,\n    )\n\n    return response, retrieved_docs\n", "type": "text"}]